worker:
  id: task-executor
  name: "Task Executor"
  type: OpsWorker
  version: "1.0"

execution:
  mode: on_demand
  max_runtime: 30m
  retry_attempts: 2

context:
  base:
    - workers/public/dev-team/task-executor/
    - workers/public/dev-team/task-executor/skills/
    - knowledge/public/dev-team/workflows/
  dynamic:
    - pattern: "projects/{project}/"
      when: always
    - pattern: "{target_repo}/"
      when: "task.has_repo"
  exclude:
    - node_modules/
    - dist/
    - "*.log"

verification:
  post_execute:
    - check: typescript
      command: npm run typecheck
  approval_required: true

output:
  destination: workspace/reports/dev-team/
  format: both
  naming: "{date}-task-executor-{issue}.{ext}"

mcp:
  server:
    command: node
    args:
      - dist/mcp-server.js
    cwd: workers/public/dev-team/task-executor
  tools:
    - execute
    - analyze_issue
    - validate_completion
    - report_learnings

# State Machine (Loom pattern)
state_machine:
  enabled: true
  max_retries: 1
  hooks:
    post_execute:
      - auto_checkpoint
      - log_metrics
    on_error:
      - log_error
      - checkpoint_error_state

instructions: |
  # Task Executor

  Executes individual issues by routing to appropriate workers and managing the execution loop.

  ## Skills

  | Skill | Description |
  |-------|-------------|
  | execute | Execute issue end-to-end: analyze → spawn workers → validate → report |
  | analyze-issue | Analyze issue to determine worker sequence |
  | validate-completion | Run back pressure checks on completed work |
  | report-learnings | Extract and format learnings from execution |

  ## CLI Usage

  ```bash
  cd workers/public/dev-team/task-executor
  node dist/index.js execute --issue US-001 --project my-feature
  node dist/index.js analyze-issue --issue US-001 --project my-feature
  ```

  ## Execution Flow

  1. Analyze issue → determine worker sequence
  2. Present plan to human → get approval
  3. For each worker phase:
     a. Show: "Spawning {worker} for {phase}"
     b. Wait for human approval
     c. Spawn worker via Task tool
     d. Show results, run validation
     e. Human approves or requests changes
  4. On completion: extract learnings, mark issue done
  5. Return learnings to project-manager

  ## Worker Sequence Selection

  Based on issue analysis:
  - API/backend changes → architect → backend-dev → qa-tester
  - Database schema → architect → database-dev → backend-dev → qa-tester
  - UI changes → architect → frontend-dev → motion-designer → qa-tester
  - Full-stack → architect → database-dev → backend-dev → frontend-dev → qa-tester

  ## Human-in-the-loop

  Every phase requires human approval:
  - Before: Show plan, get approval
  - During: Surface any ambiguity
  - After: Show changes, validate, confirm
